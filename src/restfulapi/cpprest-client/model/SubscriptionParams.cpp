/**
 * RIC subscription
 * This is the initial REST API for RIC subscription
 *
 * OpenAPI spec version: 0.0.4
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator 2.4.27-SNAPSHOT.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */



#include "SubscriptionParams.h"

namespace io {
namespace swagger {
namespace client {
namespace model {

SubscriptionParams::SubscriptionParams()
{
    m_SubscriptionId = utility::conversions::to_string_t("");
    m_SubscriptionIdIsSet = false;
    m_Meid = utility::conversions::to_string_t("");
    m_RANFunctionID = 0;
    m_E2SubscriptionDirectivesIsSet = false;
}

SubscriptionParams::~SubscriptionParams()
{
}

void SubscriptionParams::validate()
{
    // TODO: implement validation
    //m_SubcriptionId is optional
    if(m_ClientEndpoint.get())
    {
        try {
            m_ClientEndpoint->validate();
        }
        catch(const std::invalid_argument& e) {
            INVALID_ARGUMENT(ClientEndpoint);
        }
    }
    else
        INVALID_ARGUMENT(ClientEndPoint);
    
    if(m_Meid.empty())
        INVALID_ARGUMENT(Meid);

    if(m_RANFunctionID < 0 || m_RANFunctionID > 4095)
        INVALID_ARGUMENT(RANFunctionID);

    if(m_E2SubscriptionDirectives.get())
    {
        try {
            m_E2SubscriptionDirectives->validate();
        }
        catch(const std::invalid_argument& e) {
            INVALID_ARGUMENT(E2SubscriptionDirectives);
        }
    }
    else
        INVALID_ARGUMENT(E2SubscriptionDirectives);

    if(m_SubscriptionDetails.empty())
        INVALID_ARGUMENT(E2SubscriptionDirectives);
    else
    {
        try {
            for(auto it : m_SubscriptionDetails)
                it->validate();
        }
        catch(const std::invalid_argument& e) {
            INVALID_ARGUMENT(SubscriptionDetails);
        }
    }

    return;
}

web::json::value SubscriptionParams::toJson() const
{
    web::json::value val = web::json::value::object();

    if(m_SubscriptionIdIsSet)
    {
        val[utility::conversions::to_string_t("SubscriptionId")] = ModelBase::toJson(m_SubscriptionId);
    }
    val[utility::conversions::to_string_t("ClientEndpoint")] = ModelBase::toJson(m_ClientEndpoint);
    val[utility::conversions::to_string_t("Meid")] = ModelBase::toJson(m_Meid);
    val[utility::conversions::to_string_t("RANFunctionID")] = ModelBase::toJson(m_RANFunctionID);
    if(m_E2SubscriptionDirectivesIsSet)
    {
        val[utility::conversions::to_string_t("E2SubscriptionDirectives")] = ModelBase::toJson(m_E2SubscriptionDirectives);
    }
    {
        std::vector<web::json::value> jsonArray;
        for( auto& item : m_SubscriptionDetails )
        {
            jsonArray.push_back(ModelBase::toJson(item));
        }
        val[utility::conversions::to_string_t("SubscriptionDetails")] = web::json::value::array(jsonArray);
    }

    return val;
}

void SubscriptionParams::fromJson(web::json::value& val)
{
    if(val.has_field(utility::conversions::to_string_t("SubscriptionId")))
    {
        web::json::value& fieldValue = val[utility::conversions::to_string_t("SubscriptionId")];
        if(!fieldValue.is_null())
        {
            setSubscriptionId(ModelBase::stringFromJson(fieldValue));
        }
    }
    std::shared_ptr<SubscriptionParams_ClientEndpoint> newClientEndpoint(new SubscriptionParams_ClientEndpoint());
    newClientEndpoint->fromJson(val[utility::conversions::to_string_t("ClientEndpoint")]);
    setClientEndpoint( newClientEndpoint );
    setMeid(ModelBase::stringFromJson(val[utility::conversions::to_string_t("Meid")]));
    setRANFunctionID(ModelBase::int32_tFromJson(val[utility::conversions::to_string_t("RANFunctionID")]));
    if(val.has_field(utility::conversions::to_string_t("E2SubscriptionDirectives")))
    {
        web::json::value& fieldValue = val[utility::conversions::to_string_t("E2SubscriptionDirectives")];
        if(!fieldValue.is_null())
        {
            std::shared_ptr<SubscriptionParams_E2SubscriptionDirectives> newItem(new SubscriptionParams_E2SubscriptionDirectives());
            newItem->fromJson(fieldValue);
            setE2SubscriptionDirectives( newItem );
        }
    }
    {
        m_SubscriptionDetails.clear();
        std::vector<web::json::value> jsonArray;
        for( auto& item : val[utility::conversions::to_string_t("SubscriptionDetails")].as_array() )
        {
            if(item.is_null())
            {
                m_SubscriptionDetails.push_back( std::shared_ptr<SubscriptionDetail>(nullptr) );
            }
            else
            {
                std::shared_ptr<SubscriptionDetail> newItem(new SubscriptionDetail());
                newItem->fromJson(item);
                m_SubscriptionDetails.push_back( newItem );
            }
        }
    }
}

void SubscriptionParams::toMultipart(std::shared_ptr<MultipartFormData> multipart, const utility::string_t& prefix) const
{
    utility::string_t namePrefix = prefix;
    if(namePrefix.size() > 0 && namePrefix.substr(namePrefix.size() - 1) != utility::conversions::to_string_t("."))
    {
        namePrefix += utility::conversions::to_string_t(".");
    }

    if(m_SubscriptionIdIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t("SubscriptionId"), m_SubscriptionId));
        
    }
    m_ClientEndpoint->toMultipart(multipart, utility::conversions::to_string_t("ClientEndpoint."));
    multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t("Meid"), m_Meid));
    multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t("RANFunctionID"), m_RANFunctionID));
    if(m_E2SubscriptionDirectivesIsSet)
    {
        if (m_E2SubscriptionDirectives.get())
        {
            m_E2SubscriptionDirectives->toMultipart(multipart, utility::conversions::to_string_t("E2SubscriptionDirectives."));
        }
        
    }
    {
        std::vector<web::json::value> jsonArray;
        for( auto& item : m_SubscriptionDetails )
        {
            jsonArray.push_back(ModelBase::toJson(item));
        }
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t("SubscriptionDetails"), web::json::value::array(jsonArray), utility::conversions::to_string_t("application/json")));
            }
}

void SubscriptionParams::fromMultiPart(std::shared_ptr<MultipartFormData> multipart, const utility::string_t& prefix)
{
    utility::string_t namePrefix = prefix;
    if(namePrefix.size() > 0 && namePrefix.substr(namePrefix.size() - 1) != utility::conversions::to_string_t("."))
    {
        namePrefix += utility::conversions::to_string_t(".");
    }

    if(multipart->hasContent(utility::conversions::to_string_t("SubscriptionId")))
    {
        setSubscriptionId(ModelBase::stringFromHttpContent(multipart->getContent(utility::conversions::to_string_t("SubscriptionId"))));
    }
    std::shared_ptr<SubscriptionParams_ClientEndpoint> newClientEndpoint(new SubscriptionParams_ClientEndpoint());
    newClientEndpoint->fromMultiPart(multipart, utility::conversions::to_string_t("ClientEndpoint."));
    setClientEndpoint( newClientEndpoint );
    setMeid(ModelBase::stringFromHttpContent(multipart->getContent(utility::conversions::to_string_t("Meid"))));
    setRANFunctionID(ModelBase::int32_tFromHttpContent(multipart->getContent(utility::conversions::to_string_t("RANFunctionID"))));
    if(multipart->hasContent(utility::conversions::to_string_t("E2SubscriptionDirectives")))
    {
        if(multipart->hasContent(utility::conversions::to_string_t("E2SubscriptionDirectives")))
        {
            std::shared_ptr<SubscriptionParams_E2SubscriptionDirectives> newItem(new SubscriptionParams_E2SubscriptionDirectives());
            newItem->fromMultiPart(multipart, utility::conversions::to_string_t("E2SubscriptionDirectives."));
            setE2SubscriptionDirectives( newItem );
        }
    }
    {
        m_SubscriptionDetails.clear();

        web::json::value jsonArray = web::json::value::parse(ModelBase::stringFromHttpContent(multipart->getContent(utility::conversions::to_string_t("SubscriptionDetails"))));
        for( auto& item : jsonArray.as_array() )
        {
            if(item.is_null())
            {
                m_SubscriptionDetails.push_back( std::shared_ptr<SubscriptionDetail>(nullptr) );
            }
            else
            {
                std::shared_ptr<SubscriptionDetail> newItem(new SubscriptionDetail());
                newItem->fromJson(item);
                m_SubscriptionDetails.push_back( newItem );
            }
        }
    }
}

utility::string_t SubscriptionParams::getSubscriptionId() const
{
    return m_SubscriptionId;
}


SubscriptionParams& SubscriptionParams::setSubscriptionId(utility::string_t value)
{
    m_SubscriptionId = value;
    m_SubscriptionIdIsSet = true;
    return *this;
}
bool SubscriptionParams::subscriptionIdIsSet() const
{
    return m_SubscriptionIdIsSet;
}

SubscriptionParams& SubscriptionParams::unsetSubscriptionId()
{
    m_SubscriptionIdIsSet = false;
    return *this;
}

std::shared_ptr<SubscriptionParams_ClientEndpoint> SubscriptionParams::getClientEndpoint() const
{
    return m_ClientEndpoint;
}


SubscriptionParams& SubscriptionParams::setClientEndpoint(std::shared_ptr<SubscriptionParams_ClientEndpoint> value)
{
    m_ClientEndpoint = value;
    return *this;
}

utility::string_t SubscriptionParams::getMeid() const
{
    return m_Meid;
}


SubscriptionParams& SubscriptionParams::setMeid(utility::string_t value)
{
    m_Meid = value;
    return *this;
}

int32_t SubscriptionParams::getRANFunctionID() const
{
    return m_RANFunctionID;
}


SubscriptionParams& SubscriptionParams::setRANFunctionID(int32_t value)
{
    m_RANFunctionID = value;
    return *this;
}

std::shared_ptr<SubscriptionParams_E2SubscriptionDirectives> SubscriptionParams::getE2SubscriptionDirectives() const
{
    return m_E2SubscriptionDirectives;
}


SubscriptionParams& SubscriptionParams::setE2SubscriptionDirectives(std::shared_ptr<SubscriptionParams_E2SubscriptionDirectives> value)
{
    m_E2SubscriptionDirectives = value;
    m_E2SubscriptionDirectivesIsSet = true;
    return *this;
}
bool SubscriptionParams::e2SubscriptionDirectivesIsSet() const
{
    return m_E2SubscriptionDirectivesIsSet;
}

SubscriptionParams& SubscriptionParams::unsetE2SubscriptionDirectives()
{
    m_E2SubscriptionDirectivesIsSet = false;
    return *this;
}

std::vector<std::shared_ptr<SubscriptionDetail>>& SubscriptionParams::getSubscriptionDetails()
{
    return m_SubscriptionDetails;
}

SubscriptionParams& SubscriptionParams::setSubscriptionDetails(std::vector<std::shared_ptr<SubscriptionDetail>> value)
{
    m_SubscriptionDetails = value;
    return *this;
}
}
}
}
}

